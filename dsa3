3. Convert infix expression to prefix expression.
#include <stdio.h>
#include <conio.h>
#include <string.h>
#include <ctype.h>

#define MAX 100  // Maximum size for expressions and stack

// Function declarations
void push(char);
char pop();
void convertInfixToPrefix(char[], char[]);
int getPrecedence(char);

// Global stack and top pointer
char operatorStack[MAX];
int top = -1;

// Push function to add an operator to the stack
void push(char operator) {
    operatorStack[++top] = operator;
}

// Pop function to remove and return the top element from the stack
char pop() {
    return operatorStack[top--];
}

// Function to return precedence of operators
int getPrecedence(char operator) {
    if (operator == '^')
        return 3;
    if (operator == '*' || operator == '/')
        return 2;
    if (operator == '+' || operator == '-')
        return 1;
    return 0;
}

// Function to convert infix expression to prefix
void convertInfixToPrefix(char infixExpression[], char prefixExpression[]) {
    int i, prefixIndex = 0;
    char reversedExpression[MAX];

    // Reverse the infix expression
    strcpy(reversedExpression, infixExpression);
    strrev(reversedExpression);

    // Convert '(' to ')' and vice versa
    for (i = 0; reversedExpression[i] != '\0'; i++) {
        if (reversedExpression[i] == ')') {
            reversedExpression[i] = '(';
        } else if (reversedExpression[i] == '(') {
            reversedExpression[i] = ')';
        }
    }

    // Process the reversed infix expression
    for (i = 0; reversedExpression[i] != '\0'; i++) {
        char currentChar = reversedExpression[i];

        // If operand, add to prefix output
        if (isalnum(currentChar)) {
            prefixExpression[prefixIndex++] = currentChar;
        }
        // If opening parenthesis, push to stack
        else if (currentChar == ')') {
            push(currentChar);
        }
        // If closing parenthesis, pop and add to output until '(' is found
        else if (currentChar == '(') {
            while (top != -1 && operatorStack[top] != ')') {
                prefixExpression[prefixIndex++] = pop();
            }
            pop();  // Remove '(' from stack
        }
        // If operator, pop higher precedence operators and push current one
        else {
            while (top != -1 && getPrecedence(operatorStack[top]) >= getPrecedence(currentChar)) {
                prefixExpression[prefixIndex++] = pop();
            }
            push(currentChar);
        }
    }

    // Pop remaining operators from the stack
    while (top != -1) {
        prefixExpression[prefixIndex++] = pop();
    }

    // Null terminate the prefix expression
    prefixExpression[prefixIndex] = '\0';

    // Reverse the final prefix expression
    strrev(prefixExpression);
}

// Main function
void main() {
    char infixExpression[MAX], prefixExpression[MAX];

    clrscr();
    printf("Enter the infix expression: ");
    scanf("%s", infixExpression);

    // Convert infix to prefix
    convertInfixToPrefix(infixExpression, prefixExpression);

    // Display the result
    printf("\nPrefix expression: %s", prefixExpression);

    getch();
}
